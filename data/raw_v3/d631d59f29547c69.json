{
  "url": "https://about.gitlab.com/direction/security",
  "title": "Product Section Direction - Security\n|\nGitLab",
  "headings": [
    "Product Section Direction - Security",
    "On this page",
    "Section overview",
    "3 Year Section Themes",
    "Stages and Categories"
  ],
  "text": "Product Section Direction - Security\n|\nGitLab\nProduct Section Direction - Security\nMaintained by\n:\nG\nYou are here:\nGitLab Direction\nProduct Section Direction - Security\nMaintained by\n:\nG\nThe following page may contain information related to upcoming products, features and functionality. It is important to note that the information presented is for informational purposes only, so please do not rely on the information for purchasing or planning purposes. Just like with all projects, the items mentioned on the page are subject to change or delay, and the development, release, and timing of any products, features or functionality remain at the sole discretion of GitLab Inc.\nOn this page\nSection overview\nGitLab and the DevSecOps lifecycle\nLowering the cost of remediation\nClosing the loop\nGroups\nTeams and Investments\nTeam members\nInvestments\nAccomplishments, News, and Updates\n3 Year Section Themes\nScan everything, but don't get in the way\nMake better risk decisions with richer context\nTake action, not just inventory\nTop-down security controls\nNo compromises with compliance\nCoordinate governance across GitLab\nEmphasize usability and convention over configuration\nSecure the software supply chain\nStages and Categories\nApplication Security Testing (AST) stage\nCategories\nSAST\nSecret Detection\nCode Quality\nDAST\nAPI Security\nFuzz Testing\nSoftware Composition Analysis\nContainer Scanning\nGitLab Advisory Database\nAttack Emulation\nPricing\nUltimate\nFree and Premium\nSoftware Supply Chain Security (SSCS) stage\nCategories\nSystem Access\nPermissions\nAudit Events\nCompliance Management\nDependency Management\nSoftware Supply Chain Security\nInsider Threat\nInstance Resiliency\nSecrets Management\nArtifact Security\nRelease Evidence\nUser Profile\nPricing\nFree\nPremium\nUltimate\nSecurity visibility from development to operations to minimize risk\nGitLab provides the single application organizations need to find, triage, and fix vulnerabilities, from development to production. This empowers organizations to apply repeatable, defensible processes that automate security and compliance policies that proactively reduce overall security risk.\nApplication Security Testing\nSoftware Supply Chain Security\nSecurity Risk Management\nSection overview\nThe Sec section focuses on providing security and compliance visibility across the entire software development lifecycle.\nWe accomplish this by:\nShifting security testing left\n, enabling developers to begin security scanning as soon as they write their first line of code.\nProviding organizations with visibility and control over the security risk present across their environment.\nGitLab and the DevSecOps lifecycle\nGitLab is uniquely positioned to fully support DevSecOps by providing a single application for the entire software development lifecycle. This includes both shifting Application Security Testing (AST) left as well as providing visibility and control over security and compliance findings, from first line of code to production.\nGitLab's single application maps directly to the DevSecOps lifecycle. GitLab's AST stage focuses on pinpointing vulnerabilities and weaknesses, from development to production, while the Security Risk Management (SRM) stage provides visibility and control over the security findings AST detects. Software Supply Chain Security (SSCS) makes GitLab a verifiably secure foundation for software delivery. Together, GitLab supports all teams involved in delivering secure applications:\nDevelop: Developers create new source code, including new features and bug fixes, and commit this code to a branch within the project. This step is supported by the\nCreate\nstage of the DevOps lifecycle, providing developers with\nsource code management\n,\ncode editors\n, and\ncode review\nworkflows.\nAnalyze: Upon code commit, AST scanners kick off automatically and identify any new security findings with the delta code change. This enables developers to stay within context, enabling them to understand the cause and effect of their code change. AST scanners leverage the\nVerify\nstage of the DevOps lifecycle to provide scanning within the\nCI pipeline\n.\nMitigate: Developers are provided with the\ndetails needed\nto understand how to remediate the newly introduced security findings. Developers are also offered\nautomatic remediation\n, where applicable.\nProtect: AST scanners provide continuous scanning coverage for applications deployed to production, while SRM dashboards and policies and SSCS compliance frameworks help users implement their security and compliance requirements across their organization.\nLowering the cost of remediation\nRemediating security vulnerabilities earlier reduces risk and makes remediation cheaper.\nWhen security vulnerabilities are identified at the time of code commit, developers can understand how their newly\nintroduced code has led to this new issue. This gives the developer a cause-and-effect enabling quicker resolution\nwhile not having the time hit of context switching. This is not true as security scanning is performed later in the\nsoftware development lifecycle. New vulnerabilities may not be identified until weeks or months after they were added\nto the application while under development.\nTime is not the only savings when shifting security left.\nIn\nâThe Economic Impacts of Inadequate Infrastructure for Software Testingâ\n, NIST estimated the cost of remediating software bugs at $59.5 billion/year. This is compounded when taking in the average time to remediate software bugs. In\nâSoftware Development Price Guide & Hourly Rate Comparisonâ\n, FullStack Labs estimates the average cost of a software developer at $300/hour. The following table outlines the cost to remediate software bugs at different stages of the software development lifecycle:\nThese costs are just the start of the financial impact when the software bug is also a software vulnerability. IBM, in partnership with the Ponemon Institute, put the\naverage cost to remediate a data breach in 2020\nat $3.86 million (USD). This does not take into consideration the reputation impact to the organization.\nClosing the loop\nHaving visibility into security risk in just development only provides you with half of the picture. Development and\nSecOps teams need to have a closed feedback loop enabling both teams to be successful. Development teams can gain\ninsight into attacks targeting the applications they develop. This allows them to prioritize vulnerabilities correctly,\nenabling proactive resolutions to reduce risk. Likewise, SecOps teams can gain insight from their development\ncounterparts, providing them with visibility into how the application works. This allows them to best apply proactive\nmeasures to mitigate attacks targeting the application until development can fix the vulnerability.\nClosing the loop requires close collaboration, transparency, and efficiencies that only a single platform for the entire DevOps lifecycle can provide. Shifting security left while also providing protection for applications in production within a single application empowers teams to work closer together. Security is a team sport, and teams working together can best reduce their organization's overall security risk.\nGroups\nThe Sec section is made up of three stages of the DevSecOps lifecycle, along with the groups in those stages:\nApplication Security Testing (AST)\nSecurity Risk Management (SRM)\nSoftware Supply Chain Security (SSCS)\nTeams and Investments\nTeam members\nTeam members for the Sec Section can be found in the links below:\nDevelopment\nUser Experience\nProduct Management\nQuality Engineering\nInvestments\nTeam members can learn more about GitLab's investment into the Sec section by checking the\nProduct Investment\npage in the internal handbook.\nAccomplishments, News, and Updates\nA complete list of released features can be found in the\nRelease Feature Overview\n.\n3 Year Section Themes\nScan everything, but don't get in the way\nThe increasing pace of modern software development demands that we push security testing further left than before, integrating it into existing workflows rather than forcing teams to adapt their processes or context-switch to separate tools.\nMoving security scanning directly into the IDE and pre-commit stages enables developers to catch vulnerabilities, exposed secrets, and dependency issues before they even enter the codebase, dramatically reducing remediation costs and team overhead.\nFor this proactive approach to succeed, security tools must provide clear, actionable feedback that developers can understand without deep security expertise, including precise code locations and step-by-step remediation guidance with examples of secure coding patterns.\nBy making security both approachable and efficient, we help organizations build a true DevSecOps culture where security becomes a natural part of every developer's daily work, transforming how organizations approach application security while significantly reducing the burden on overburdened security specialists.\nTo achieve this theme, GitLab will pursue capabilities like:\nDelivering scan results at the speed of software development by offering:\nReal-time scanning for SAST and SCA vulnerabilities and leaked secrets.\nIntelligent incremental scans that avoid re-scanning parts of the application that haven't changed.\nIdentifying runtime security issues early in the development phase with DAST unit tests and by running DAST scans in development environments like `localhost`.\nIntegrating Secret Detection scanning across the platform to prevent leaked secrets in every written place like descriptions and comments on issues, epics, and merge requests, wikis, and more.\nAutomatically scanning for CVEs in repositories and registries for dependencies, packages, and containers.\nDetecting malicious packages and prevent them from entering your software supply chain\nMake better risk decisions with richer context\nIn today's complex security landscape, presenting raw vulnerability data without context can lead teams to work on less impactful tasks or accept risks without realizing the consequences. That doesn't work well for anyone.\nBy combining multiple security scanning methods and leveraging more advanced techniques like AI and machine learning, we can provide deeper context and more accurate risk assessments for each security finding. This intelligence-driven approach helps teams cut through the noise of security alerts, focusing remediation efforts on vulnerabilities that pose the greatest actual risk to their applications. Integration across different security disciplines creates a comprehensive view of each vulnerability's impact and exploitability, enabling more confident decision-making about when and how to remediate issues.\nThe power of machine learning transforms security scanning from a simple detection tool into an intelligent advisory system that helps teams make informed, strategic decisions about their security posture and resource allocation.\nTo achieve this theme, GitLab will pursue capabilities like:\nIntegrating detection capabilities across scanning disciplines to provide more actionable outcomes.\nUsing SAST for advanced tasks like reachability analysis and API discovery, so we can enrich DAST and other scanning processes.\nCorrelating and deduplicating scanning outputs to reduce noise, uncover the most urgent exploitable issues, and focus attention on the most impactful remediations.\nLeveraging AI/ML to reduce false positives by understanding normal code structure, commit history, and runtime behavior.\nTake action, not just inventory\nWhen tools identify vulnerabilities but don't provide a clear path to resolution, organizations end up exposed to security risks for longer than necessary. Worse still, as backlogs of security issues grow, organizations end up accepting risks without realizing itâan untriaged and unresolved vulnerability is one that's tacitly accepted.\nModern security tools must go beyond detection to provide automated remediation pathways that help both developers and security teams efficiently address vulnerabilities.\nDevelopers can make larger impacts when they receive automated merge requests for dependency updates, intelligent suggestions for fixing vulnerable code, and clear guidance on implementing secure alternatives directly within their development environment.\nSecurity professionals benefit from automated workflows that can immediately revoke exposed secrets, quarantine vulnerable dependencies, and orchestrate large-scale security updates across multiple repositories without manual legwork.\nAs applications and security threats grow more complex, effective security programs have to rely on automation to scale up. By transforming security findings into automated actions, intelligent tools help organizations dramatically reduce their mean time to remediation while allowing both development and security teams to focus on strategic work rather than routine maintenance.\nTo achieve this theme, GitLab will pursue capabilities like:\nAutomating remediation actions like revoking exposed secrets, blocking insecure code, and upgrading vulnerable dependencies.\nContinuing to invest in GitLab Duo Vulnerability Explanation and Vulnerability Resolution to produce better recommendations.\nProviding automated system hardening, such as removing dependencies that are not in use.\nImproving AST scan results so that they are easier to understand and act on.\nTop-down security controls\nSecurity teams need centralized management for their security and compliance workflows. Features such as user management, compliance labels, security policies, and the vulnerability and dependency lists need to allow for centralized management that applies across all of an organization's projects.\nNo compromises with compliance\nSSCS capabilities will ensure that compliance regulations are strictly followed in a way that they cannot be bypassed without the proper approvals. This includes providing the necessary tools to audit, monitor, and manage the compliance controls that are enforced.\nCoordinate governance across GitLab\nSSCS capabilities will serve as a connection point for a seamless workflow spanning across the DevSecOps lifecycle. By enabling collaboration between types of users, SSCS can help solidify the advantages GitLab has to offer as a single application. For example, these areas might include the following:\nFacilitating a continuous experience for scanning across repositories, registries, and production environments.\nCentralizing security and compliance controls across GitLab, including merge request approvals, anomalous user activity, and anomalous pipeline/job activity.\nLeveraging data about production environment configuration to reduce false positives in scanners.\nLeveraging data about vulnerabilities in development to inform and drive threat mitigation in production.\nEmphasize usability and convention over configuration\nSSCS capabilities will be\npre-configured with reasonable defaults\nout-of-the-box whenever possible. When not possible, they will be easy to configure either through code or through a guided UI workflow that is friendly to users without coding knowledge. Regardless of how the capabilities are configured, they will be stored as code for ease of management.\nFor example, GitLab's\nsecurity policy editor\nsupports editing policies in both a\nrule mode\nand in\nyaml mode\n.\nSecure the software supply chain\nSSCS capabilities allow organizations to lock down every aspect of their supply chain. This includes securely authenticating users into GitLab, hardening the GitLab platform itself, and verifying every step along the DevSecOps lifecycle as code is created, built, and deployed.\nStages and Categories\nThe Sec section is composed of two stages,\nSecure\nand\nGovern\n, each of which contains several categories. Each stage has an overall\nstrategy statement below, aligned to the themes for Sec. Each category within each stage has a dedicated direction page\nplus optional documentation, marketing pages, and other materials linked below.\nApplication Security Testing (AST) stage\nThe Application Security Testing (AST) stage helps customers find vulnerabilities in applications before they reach production.\nWe focus on developing scanning capabilities to find these vulnerabilities, then we work closely with the\nSecurity Risk Management\nand\nSoftware Supply Chain Security\nstages to ensure that organizations can take action on the vulnerabilities our scanners detect.\nGitLab was named as a\nChallenger in the 2022 Magic Quadrant for Application Security Testing\n.\nCategories\nSAST\nScans your application source code and binaries to spot potential vulnerabilities before deployment. SAST supports scanning a variety of different programming languages and automatically chooses the right analyzer even if your project uses more than one language. Vulnerabilities, additional data, and solutions are shown in-line with every merge request. Scanner results are collected and presented as a single report. This category is at the \"complete\" level of maturity.\nPriority: high â¢\nDocumentation\nâ¢\nDirection\nSecret Detection\nScans your repository to help prevent your secrets from being exposed. Secret Detection scanning works on all text files, regardless of the language or framework used. Code pushed to a remote Git branch can be rejected if a secret is detected. This category is at the \"viable\" level of maturity.\nPriority: medium â¢\nDocumentation\nâ¢\nDirection\nCode Quality\nAnalyzes your source code quality and complexity. This helps keep your projectâs code simple, readable, and easier to maintain. This category is at the \"minimal\" level of maturity.\nDocumentation\nâ¢\nDirection\nDAST\nRuns automated penetration tests to find vulnerabilities in web applications and APIs as they are running. DAST can run live attacks against a Review App, an externally deployed application, or an active API. Scans can be run for every merge request, on a schedule, or even on-demand. DAST supports user inputted HTTP credentials to test private areas of your application. Vulnerabilities, additional data, and solutions are shown in-line with every merge request. Scanner results are presented as a single report. This category is at the \"complete\" level of maturity.\nPriority: high â¢\nDocumentation\nâ¢\nDirection\nAPI Security\nSecures and protects web Application Programming Interfaces from unauthorized access, misuse, and attacks. Tests for known vulnerabilities by performing penetration testing of APIs with DAST. Finds unknown vulnerabilities by performing Fuzz Testing of web API operation parameters.Users can provide credentials to test authenticated APIs. Vulnerabilities, additional data, and solutions are shown in-line with every merge request.. Scanner results are collected and presented as a single report. This category is at the \"complete\" level of maturity.\nPriority: high â¢\nDocumentation\nâ¢\nDirection\nFuzz Testing\nSends random inputs to an instrumented version of your application in an effort to cause unexpected behavior in order to identify a bug that needs to be addressed. Helps you discover bugs and potential security issues that other QA processes may miss. This category is at the \"complete\" level of maturity.\nPriority: high â¢\nDocumentation\nâ¢\nDirection\nSoftware Composition Analysis\nAnalyzes external dependencies within your application for known vulnerabilities on each CI/CD code commit. Vulnerabilities, additional data, and solutions are shown in-line with every merge request. Scanner results are collected and presented as a single report. Upon code commit, project dependencies are searched for approved and denied licenses defined by per project custom policies. Software licenses are identified if they are not within policy and are shown in-line for every merge request for immediate resolution. This category is at the \"viable\" level of maturity.\nPriority: high â¢\nDocumentation\nâ¢\nDirection\nContainer Scanning\nScans your container images for known vulnerabilities within the application environment. Image contents are analyzed against public vulnerability databases.Security findings, additional data, and solutions reported in-line with every merge request along with additional data including solutions. Results are presented as a single report. Container Scanning is considered part of Software Composition Analysis. This category is at the \"viable\" level of maturity.\nPriority: medium â¢\nDocumentation\nâ¢\nDirection\nGitLab Advisory Database\nThe GitLab Advisory Database serves as a repository for security advisories related to software dependencies. GitLab integrates the advisory database with its proprietary and open-source application security scanning tools. In order to maintain the efficacy of those scanners, we strive to keep their underlying vulnerability databases up-to-date.\nPriority: high â¢\nDirection\nAttack Emulation\nContinuously assess your applications and services are not vulnerable to security threats through automated, real-world emulated scenarios to identify weaknesses in your attack surface\nPriority: low\nPricing\nApplication Security Testing pricing and tiering reflects GitLab's overall\npricing model\n.\nUltimate\nWe focus our efforts primarily on Ultimate.\nAdvanced security is\nan Ultimate pricing theme\nand helps customers deliver on organization-wide security and compliance priorities.\nAdvanced features, including technology developed in-house at GitLab and technology we've\nacquired\n, are available only in Ultimate.\nFree and Premium\nWe make a subset of our AST scanners available in all tiers (including Free).\nWe typically do this when the scanners are themselves open-source.\nWe do not specifically focus on Premium.\nSoftware Supply Chain Security (SSCS) stage\nThe Software Supply Chain Security (SSCS) stage helps organizations to reduce their overall risk by applying appropriate management and governance oversight across the entire DevSecOps lifecycle. SSCS provides management tools to secure the GitLab platform itself by restricting access to authenticated users and ensuring they are provisioned with the least amount of required privileges. To help manage and monitor risk levels, the SSCS stage provides visibility into user permissions and activity; project dependencies; security findings; and adherence to compliance standards. This visibility is then coupled with enforcement capabilities to proactively prevent risks by automating compliance and securing the software supply chain.\nCategories\nSystem Access\nSystem Access provides tools to authenticate through all points of GitLab (UI, CLI, API). These tools allow you to configure what an individual/process has access to once they authenticate, determined by their role. GitLab integrates with several OmniAuth providers, LDAP, SAML, and more.\nDocumentation\nâ¢\nDirection\nPermissions\nGitLab provides various permissions and roles in order to evaluate what access or rights an identity should have in an environment. Custom roles can also be created to allow an organization to create user roles with the precise privileges and permissions desired.\nDocumentation\nâ¢\nDirection\nAudit Events\nAudit Events track important actions within GitLab along with who performed the actions and the time in which they occurred. These events can be used in a security audit to assess risk, strengthen security measures, respond to incidents, and adhere to compliance. This category is at the \"viable\" level of maturity.\nPriority: high â¢\nDocumentation\nâ¢\nDirection\nCompliance Management\nCompliance Management provides customers with the tools necessary to ensure and manage their compliance programs. Compliance Workflow Automation is provided to enforce custom pipelines to run on projects which have specific compliance needs. For compliance oversight, the Compliance Center provides a central location for compliance teams to manage their compliance standards adherence reporting, violations reporting, and compliance frameworks for their group. This category is at the \"viable\" level of maturity.\nPriority: high â¢\nDocumentation\nâ¢\nDirection\nDependency Management\nDependency Management allows users to review project/group dependencies and key details about those dependencies, including their vulnerabilities, licenses, and packager. This category is at the \"viable\" level of maturity.\nPriority: high â¢\nDocumentation\nâ¢\nDirection\nSoftware Supply Chain Security\nGitLab allows you to secure your software supply chain including push rules, code scanning, SBOM management, and enforcement of compliance policies. This category is at the \"viable\" level of maturity.\nPriority: high â¢\nLearn more\nâ¢\nDocumentation\nâ¢\nDirection\nInsider Threat\nInsider Threat identifies attacks and high risk behaviors by correlating different data sources and observing user behavioral patterns\nDirection\nInstance Resiliency\nInstance Resiliency provides tools to prevent malicious activity from occurring within GitLab Instances. These tools include external pipeline validation allowing you to use an external service to validate a pipeline before it is created.\nDocumentation\nâ¢\nDirection\nSecrets Management\nSecure and protect access to secrets, such as API keys and passwords, to ensure that sensitive data is protected throughout your development process. This category is at the \"viable\" level of maturity.\nDocumentation\nâ¢\nDirection\nArtifact Security\nArtifact Security focuses on the hardening of artifacts, to ensure the authenticity of artifacts.\nDocumentation\nâ¢\nDirection\nRelease Evidence\nRelease Evidence provides assurances and evidence collection that are necessary for you to trust the changes you're delivering. When a release is created, GitLab takes a snapshot of relevant release data as evidence that it occurred. This category is at the \"complete\" level of maturity.\nDocumentation\nâ¢\nDirection\nUser Profile\nManaging your user profile and configuring what will be visible to others.\nPriority: low â¢\nDocumentation\nâ¢\nDirection\nPricing\nSSCS is focused on providing governance and compliance features that span across the DevSecOps lifecycle. SSCS's tiering strategy aligns with the GitLab approach of selecting the tier based on\nwho cares most about the feature\n. Because Executives generally care most about governance features, it is expected that most SSCS features will land in the Ultimate tier.\nFree\nThis tier is the primary way to increase broad adoption of the SSCS stage, as well as encouraging community contributions and improving security across the entire GitLab user base.\nAs a general rule of thumb, features will fall in the Free tier when they meet one or more of the following criteria:\nThe feature is highly useful for an individual with a few small projects rather than meeting the needs of an organization or enterprise that is operating at scale.\nThe feature is provided by an integration with an open source project rather than being natively developed by GitLab.\nPremium\nThis tier is not a significant part of SSCS's pricing strategy; however, a few features features that primarily appeal to Directors rather than Executives may fall into the Premium tier. One example of this is our audit event functionality that is available in this tier.\nUltimate\nThis tier is the primary focus for the SSCS stage as most SSCS features enable executives to ensure that their organization meets compliance requirements and maintains an acceptable security posture.\nAs a general rule of thumb, features will fall in the Ultimate tier when they meet one or more of the following criteria:\nThe feature is focused on enabling an organization or enterprise to operate at scale rather than an individual with a few small projects.\nThe feature is natively developed by GitLab rather than being provided by an open source project.\nLast Updated: 2025-02-20\nEdit this page\nView source",
  "html_file": "d631d59f29547c69.html"
}