{
  "url": "https://about.gitlab.com/direction/supply-chain",
  "title": "Software Supply Chain Security Direction\n|\nGitLab",
  "headings": [
    "Software Supply Chain Security Direction",
    "Background",
    "How SSCS applies to GitLab",
    "Current Position and Vision",
    "Strategy",
    "Highlighted epics and issues",
    "What's next & why",
    "What are we not doing",
    "Competitive landscape",
    "Frameworks",
    "North Stars",
    "Analyst Landscape"
  ],
  "text": "Software Supply Chain Security Direction\n|\nGitLab\nSoftware Supply Chain Security Direction\nMaintained by\n:\nContribute to this page\nEdit this page\nYou are here:\nGitLab Direction\nSoftware Supply Chain Security Direction\nThe following page may contain information related to upcoming products, features and functionality. It is important to note that the information presented is for informational purposes only, so please do not rely on the information for purchasing or planning purposes. Just like with all projects, the items mentioned on the page are subject to change or delay, and the development, release, and timing of any products, features or functionality remain at the sole discretion of GitLab Inc.\nBackground\nHow SSCS applies to GitLab\nCurrent Position and Vision\nSource\nInternal Sources\nExternal Sources\nBuild\nBuild Execution\nProvenance and Signing\nConsumption\nBinary Acceptance\nManagement Process\nTool Security\nStrategy\nHighlighted epics and issues\nWhat's next & why\nWhat are we not doing\nCompetitive landscape\nFrameworks\nNorth Stars\nAnalyst Landscape\nThe\nSec Section\ncoordinates GitLab's overall direction for\nSoftware Supply Chain Security (SSCS)\n.\nMany groups are involved in delivering a comprehensive, quality secure supply chain experience at GitLab.\nOur goal is to deliver capabilities in the GitLab platform that gives users confidence in the integrity and security of their software supply chain.\nThis direction page is intended to facilitate collaboration and describe the product capabilities that would contribute to this vision.\nBackground\nIn today's software-driven world, your applications aren't just what you code - they're built from hundreds of components from across the global software supply chain. While this accelerates innovation, it also introduces new risks. GitLab gives you visibility into these risks and provides ways to remediate them.\nSoftware Supply Chain Security (SSCS) seeks to manage the full spectrum of security risks that may be introduced by people, processes, or technology throughout planning, building, deploying, and operating an application, from concept to sunset. Recent high-profile attacks like SolarWinds have shown that compromised dependencies can have devastating consequences. Meanwhile, new regulations like the\nUS Executive Order on Cybersecurity\nand\nEU Cyber Resilience Act\nare making supply chain security a compliance requirement.\nShared understanding of SSCS's scope has evolved significantly over the past few years. What was once rooted rather narrowly in managing third-party dependency risk has evolved into a robust set of standards and approaches that address practices across the full spectrum of software development activities. A central concern of SSCS and its primary \"output\" is a software artifact's\n1\nchain of custody. This chain of custody materializes in a variety of ways:\nA software bill of materials (SBoM) specifies what comprises a software artifact, including any third-party code, along with other facts about where it's coming from and how it was producedâanalogous to an \"ingredient label\" for the product.\nSupply-chain Levels for Software Artifacts\n(SLSA) specifies guidelines and appropriate types of evidence about other parts of the software production process. Continuing the SBOM-as-ingredient-list analogy, SLSA\nis described\nas \"the food safety handling guidelines that make an ingredient list credible\". SLSA is not a single standard, so organizations and products satisfy different tracks and levels of its guidelines.\nNIST's\nSecure Software Development Framework\n(SSDF) and accompanying practical guides from the Enduring Security Framework partnership (\nexample\n) outline a core set of high-level secure software development practices that can be integrated into any SDLC implementation. They categorize these practices into four groups: prepare the organization, protect the software, produce well-secured software, and respond to vulnerabilities.\nTogether, these concepts, documents, and standards are increasingly being embedded in industry requirements and regulations. Although the supply chain security space is still rapidly evolving, the U.S. Government has already begun implementing requirements for federal vendors. We expect that supply chain requirements will continue to evolve for the foreseeable future as part of federal regulations, regulated-industry standards, and individual organizational requirements.\nAs a single application for the DevSecOps lifecycle, GitLab is uniquely positioned to meet all of the requirements.\nHow SSCS applies to GitLab\nSSCS applies to GitLab in more than one way:\nAs a company building a product:\nWe produce software artifacts for customers, and these customers require us to make assertions about the quality and provenance of the artifacts we provide.\nWe consume software artifacts from other sources, including open-source software that we redistribute to our customers as part of our product.\nAs a product enabling customers to build their own products:\nWe enable customers to securely produce and consume software.\nWe host software projects, and build and distribute software artifacts, making us a key part of the supply chain.\nThis direction focuses on the capabilities we provide to customers, so they can securely produce and consume software.\nCurrent Position and Vision\nWe believe that there are five main aspects to consider when providing for a secure end-to-end software supply chain.\nSource\n- includes the controls needed to be confident that both internal and external source code is safe from vulnerabilities and has not been compromised in any way.\nBuild\n- includes rigorous requirements for the security and isolation of build environments as well as the automatic generation of provenance.\nConsumption\n- includes the ability to validate authenticity and source of any executed binaries. Supports requirements for securing the underlying host infrastructure itself.\nManagement Process\n- this component spans across all other aspects of SSCS and includes both the tools and processes necessary to provide for ongoing visibility into compliance SSCS requirements.\nTool Security\n- this component spans across all other aspects of SSCS and includes the adoption of best practices for managing the security of the underlying tools themselves.\nThe state of GitLab product capabilities required to address each of the five aspects of SSCS currently spans the spectrum from vision items to complete features:\nSource\nThe approach for protecting code sources can be subdivided by thinking about protection for Internal Sources separately from protection for External Sources.\nStatus Legend / Key\nIcon\nMeaning\nâ\nFeature is considered complete\nð¨\nFeature exists and still has areas for improvement\nâ\nFeature is part of the vision and has not yet been built inside GitLab\nInternal Sources\nKey Requirements\nStatus\nGitLab Group\nCurrent Capabilities\nFuture Vision\nVersion control and code history\nâ\nCreate:Source Code\nVersion control\nand code history retention is fully supported in GitLab as part of Git.\nÂ\nDeveloper identity verification\nâ\nCreate:Source Code\nGPG key signing\nis and\nSSH key signing\nare both fully supported by GitLab. Additionally,\npush rules\ncan be configured to reject commits that are not GPG key signed. On GitLab.com, commits made through the webUI are signed by default using an SSH key. Self managed instance administrators can configure default signing through the webUI to happen through either SSH or openPGP.\nTo further mature in this area, we are\nconsidering also adding support for GitSign\nto sign all commits that are made in the GitLab UI by using the user's GitLab OIDC identity. This work is blocked due to the lack of a Ruby Sigstore library.\nEnforced two-person code review and security review for vulnerabilities\nâ\nCreate:Code Review\nGitLab has a\nrobust approval system\ncapable of requiring two-person review, including from an approver who is also not the code owner.\nAlthough this feature is generally considered to be complete, improvements are ongoing.\nBranch protection rules and vulnerability approval rules\nâ\nCreate:Source Code\nand\nSRM:Security Policies\nGitLab fully supports the ability to create\nbranch protection rules\nand\napproval rules\nÂ\nDependency protection rules\nâ\nPackage:Package\nÂ\nThe vision is to empower users to create\ncontainer image\nand\npackage\nprotection rules to further restrict who can update your critical dependencies.\nAbility to restrict merge access by defining project maintainers\nâ\nSSCS:Authorization\nGitLab fully\nsupports this requirement\n.\nÂ\nMultiple types of code scanning: Secret Detection, SAST, DAST, API Fuzzing, Coverage Guided Fuzzing\nâ\nAST\nUsers can run a wide variety of scanners natively through GitLab. They can manage the results and require approval for merge requests where new vulnerabilities are identified.\nAlthough this feature is generally considered to be complete for the purposes of SSCS, improvements are ongoing. Among other things, GitLab strives to continually expand the coverage, accuracy, and language support of our scanners.\nControlled development environments\nâ\nCreate:Remote Development\nCurrently GitLab has integrations with tools such as\nGitPod\nthat allow software engineers to do their development in a remote environment.\nThe\nfuture vision\nis for GitLab to host a remote environment that is tightly integrated with GitLab and that can be managed and updated centrally. Centrally managing this environment reduces the number of tools that need to be installed on individual development environments and can help to protect against malware and code tampering.\nExternal Sources\nKey Requirements\nStatus\nGitLab Group\nCurrent Capabilities\nFuture Vision\nSCA scanning\nâ\nAST:Composition Analysis\nUsers can continuously scan both their application dependencies and their system dependencies for vulnerabilities. They can manage the results of these scans within GitLab and can require approval for merge requests where new vulnerabilities are identified.\nAlthough this feature is generally considered to be complete for the purposes of SSCS, improvements are ongoing. Among other things, GitLab strives to continually expand the coverage, accuracy, and language support of our scanners.\nDependency risk analysis\nâ\nAST:Composition Analysis\nÂ\nThis includes the ability to analyze metadata available for a dependency, as well as analyzing the source code itself to generate an overarching risk score for the dependency. Among other things, some of this data might include whether or not the dependency is well maintained, whether it has supply chain security protections in place, whether not not it contains known malicious code or obfuscated code.\nAutomated dependency updates\nâ\nAST:Composition Analysis\nGitLab has the ability to\ngenerate merge requests\nthat can attempt to fix container scanning and some dependency scanning vulnerabilities.\nThe vision is to automatically generate merge requests to keep dependencies up-to-date with the latest versions.\nDependency graph\nâ\nAST:Composition Analysis\nÂ\nGitLab has plans to add a\ndependency tree visualization\nfeature into GitLab for easier visualization of the dependencies that exist between external sources.\nBinary scanning of dependencies\nâ\nAST:Composition Analysis\nÂ\nBasic SCA scanning compares installed package names and versions to a database of known vulnerabilities. Binary scanning takes this one step further by inspecting the contents of the binary itself using static analysis tools to detect potential vulnerabilities.\nBehavioral analysis of dependencies\nâ\nAST:Composition Analysis\nÂ\nThe vision is for users to be able to analyze the behavior of their dependencies using GitLab. Observing key events such as system calls, network connectivity, and file reads during the test stage of the CI pipeline can provide insights into whether or not an upstream dependency has potentially become compromised in some way.\nVerification of provenance\nâ\nAST:Composition Analysis\nÂ\nThe vision is to allow users to verify and validate published attestation or provenance for upstream dependencies (if it exists) as part of the CI pipeline and alert on any dependencies that do not meet established criteria.\nDependency firewall\nâ\nPackage:Package\nÂ\nThe vision is to\nbuild a dependency firewall into GitLab\n. This would allow users to configure rules to prevent use of dependencies that do not match established rules. This can help protect against typosquatting attacks and can block packages that have concerning characteristics.\nBuild\nBuild Execution\nKey Requirements\nStatus\nGitLab Group\nCurrent Capabilities\nFuture Vision\nSupport for scripted builds from code\nâ\nVerify\nGitLab supports the ability to run\nCI/CD pipelines\nand both execute and deploy scripted builds from code.\nÂ\nSecure, ephemeral, and isolated build environment\nâ\nVerify:Runner\nThis is supported as long as the runners are\nproperly secured\n. Use of non-privileged Docker executors is recommended.\nÂ\nSupport for hermetic builds\nâ\nVerify:Runner\nGitLab supports the ability to\nlimit network access to runners\n. Runners do require connectivity to the GitLab server.\nÂ\nMachine identity verification for all sources\nâ\nVerify\nUsers who desire this feature would currently need to build/script this verification themselves.\nThe vision for this is to include some additional verification checks to be confident that all sources are coming from trusted, verified locations.\nProvenance and Signing\nKey Requirements\nStatus\nGitLab Group\nCurrent Capabilities\nFuture Vision\nBuild output signing\nâ\nVerify:Runner\nGitLab currently supports a\nnative integration with Sigstore\nwhich allows users to easily sign their builds through Cosign.\nFuture work is planned to allow the GitLab Runner to\nsign build outputs automatically\nwithout requiring manual configuration on the part of users.\nProvenance/Attestation generation for build outputs\nð¨\nVerify:Runner\nCurrently GitLab can be used to\ngenerate a provenance metadata document\nfor all build artifacts. Users who wish to have this document signed can do so through our\nintegration with Sigstore\n.\nFuture work is planned to allow the GitLab Runner to\nsign attestation files automatically\nwithout requiring manual configuration on the part of users.\nRelease evidence generation\nð¨\nRelease:Release\nGeneration and publication of\nrelease evidence\nis currently supported.\nRelease evidence will ideally be expanded to include an SBOM of all dependencies as well as the provenance/attestation that was generated at the time the build was created.\nSBOM generation and management\nð¨\nAST:Composition Analysis\nGitLab is currently able to generate a SBOM of application and system dependencies. This is displayed on the Dependency List page where users can easily view all the included packages along with their version and any vulnerabilities that have been detected. Additionally, a JSON CycloneDX formatted artifact can be produced in the CI pipeline.\nIn the future, GitLab plans to add support for\nexporting the dependency list\nin SPDX and CycloneDX formats. Eventually this SBOM is envisioned to be signed and included in any generated provenance/attestation documents that are produced.\nConsumption\nBinary Acceptance\nKey Requirements\nStatus\nGitLab Group\nCurrent Capabilities\nFuture Vision\nBinary authorization enforcement to validate and verify provenance\nâ\nConfigure:Configure\nÂ\nGitLab already supports continuous deployment through the GitLab Kubernetes Agent. Ideally this will be extended to validate and verify the provenance/attestation for container images prior to deploying them in production. In addition, regular scans might be done to verify on an ongoing basis that Binary Authorization has been set up within the production environment and to further validate and confirm that all running deployments meet established policies. One tool that might be used for this in the future is\nKritis\nValidation and verification of source machine identities\nâ\nConfigure:Configure\nThis requirement is met by default for users who deploy to production using GitLab for continuous deployment. The\nGitLab Kubernetes Agent\nautomatically verifies and validates the authenticity of the GitLab server certificate that it connects to.\nÂ\nManagement Process\nKey Requirements\nStatus\nGitLab Group\nCurrent Capabilities\nFuture Vision\nReporting on adherence to compliance standards\nð¨\nSSCS:Compliance\nGitLab support several\ncompliance reports\nnatively in GitLab. Additional data can also be collected through the API or monitored through GitLab Audit Events.\nWork on a centralized dashboard showing compliance with\nSLSA\nand other similar standards is part of GitLab's vision.\nEnforcement of secure settings\nð¨\nSRM:Security Policies\nSecurity and compliance teams can currently enforce a wide variety of controls, including requiring scans to be run, enforcing security-related configuration settings, and maintaining requirements related to merge request approvals.\nThe vision is for Security and Compliance teams to be able to enforce\nall\naspects of SSCS in a way that other users are unable to disable or change those settings.\nCredential management\nð¨\nSSCS:Authentication\nSelf managed users are currently able to enforce requirements related to\nSSH keys\n,\nSSH access\n, and\nPersonal Access Tokens (PAT)\n.\nThe vision is to\nprovide SaaS users with feature parity\nfor managing SSH keys, SSH access, and PAT access policies.\nTool Security\nKey Requirements\nStatus\nGitLab Group\nCurrent Capabilities\nFuture Vision\nAudit logs\nð¨\nSSCS:Compliance\nGitLab has a robust\naudit logging system\nin place today.\nAdditional audit events are regularly being added into GitLab.\nAccess controls\nð¨\nSSCS:Authorization\nGitLab supports multiple\nauthentication and authorization\noptions today, including\nsupport for custom roles\n.\nGitLab is planning to add support for\nadditional custom permissions\nso that users can be configured with the least privileges required to do their job.\nThreat detection\nâ\nSSCS:Authentication\nand\nSSCS:Compliance\nUsers can integrate external systems with GitLab to analyze suspicious behavior.\nGitLab has an opportunity to leverage anomaly detection and machine learning to detect and stop threats. This can be used to analyze user behavior as well as activity on the GitLab server itself.\nStrategy\nIn the long-term, our strategy is to become a complete provider for all aspects of software supply chain security. Providing all of these aspects within a single application not only supports GitLab's broader\nSingle Application Strategy\nbut also provides numerous tangible benefits for users.\nAmong other things, using a single application:\nminimizes the number of different tools that need to be hardened and monitored.\nreduces the number of potential points of security failure as data is transferred between various tools.\nenables seamless interoperability.\nsimplifies visibility and traceability for audits.\nHighlighted epics and issues\nThere are a few epics and important issues you can check out to see where we're headed. More will be added here as we develop this vision further.\nDependency Management Vision\nArtifact Data Store\nRelease Evidence Viability\nWhat's next & why\nAlthough we support\nsigning of build artifacts through Sigstore\n, the user experience for signed container images in GitLab is not ideal as signatures show up on a separate line item from the container image that they have signed. In 16.11 we plan to address this by associating container images with their signatures in the UI to make it easier to see which images are signed and to more easily validate those signatures.\nAdditionally, we are continuing ongoing work to explore whether we can automatically sign build artifacts natively in the GitLab Runner. Automatic signing is believed to be the best way to get widespread adoption of signing.\nA full list of the SSCS working group's current priorities can be viewed\non this working group page\n.\nWhat are we not doing\nSigstore currently has two key limitations that impact GitLab:\nSigstore does not have a Ruby library\nSigstore does not have good support for deploying and running a self managed Sigstore instance\nWe do not currently plan to address either of these limitations directly and instead are hoping to work with the wider community to find alternate solutions. Because of these feature gaps, we do not plan on adding support for our Sigstore integration for self managed instances. We also are limited in our ability to natively validate Sigstore signatures within GitLab due to the lack of Ruby support.\nCompetitive landscape\nThere have been indications that Tekton and Sigstore are tools representing a leader in software supply chain security. One example of how this has been used in practice can be found in this\nblog\n.\nCoSign\nis an open source tool that can be used for container signing.\nGrafeas\nis an open-source artifact metadata datastore tool which offers flexible, universal artifact metadata storage - a key foundation for software supply chain security.\nFrameworks\nSupply chain Levels for Software Artifacts (SLSA)\nThe\nSLSA framework\nis an open source specification that is primarily focused on preventing artifacts from being tampered with as they are coded, developed, and published. Our vision for SSCS includes adding native support for SLSA with the objective of eventually fully supporting all the way up to SLSA level 3. GitLab already supports users who want to attain SLSA L1. GitLab is currently exploring ways to natively generate the required provenance data for SLSA as part of its Runner that does the build. For more details on SLSA, view the\nSLSA requirements\n.\nThe Update Framework (TUF)\nThe Update Framework (TUF)\nis an open source specification for that provides instructions on how to organize, sign, and interact with metadata to secure package managers. Our vision for SSCS includes adding native support for TUF in the future by including the required metadata in the software provenance that we plan to generate and by validating signatures at each step of the software lifecycle. TUF leverages a Kritis store to manage metadata from in-toto. TUF recommends the use of an OCI image-spec container registry, aligned with our Container Registry's\ndocumentation\n. Some gaps to consider for GitLab are the rotation of secrets and key management, which is a part of\nSecrets Management direction\n.\nTUF also recommends the\nverification of deployments\n.\nFor more details on TUF, view the\nCNCF TUF specifications\n.\nNorth Stars\nA FY23 theme for the\nVerify Stage\nis to support pipeline safety throughout the software development lifecycle to automatically ensure compliance and security. This is complimented by Software Composition Analysis Group's\nDependency Scanning direction\non SBOM.\nWe aim to make a seamless experience for verifying trust at every step in the software chain.\nAnalyst Landscape\nGartner has published some information on this topic in a paper titled\nHow Software Engineering Leaders Can Mitigate Software Supply Chain Security Risks\n. Gartner has also published a market guide for\nCompliance Automation Tools in DevOps\n.\nLast Reviewed: 2025-02-10\nLast Updated: 2025-02-10\nA \"software artifact\" is a generic term that may refer to software binaries, container images, packages, or other ways of distributing software.Â\n↩\nEdit this page\nView source",
  "html_file": "65059c973876e364.html"
}