{
  "url": "https://about.gitlab.com/direction/delivery",
  "title": "Delivery Direction\n|\nGitLab",
  "headings": [
    "Delivery Direction",
    "Overview",
    "GitLab's Delivery Vision",
    "Jobs To Be done",
    "Product principles",
    "Strategy",
    "Roadmap",
    "Key Capabilities for Delivery"
  ],
  "text": "Delivery Direction\n|\nGitLab\nDelivery Direction\nMaintained by\n:\nMike Flouton\n@mflouton\nContribute to this page\nEdit this page\nYou are here:\nGitLab Direction\nDelivery Direction\nThe following page may contain information related to upcoming products, features and functionality. It is important to note that the information presented is for informational purposes only, so please do not rely on the information for purchasing or planning purposes. Just like with all projects, the items mentioned on the page are subject to change or delay, and the development, release, and timing of any products, features or functionality remain at the sole discretion of GitLab Inc.\nOverview\nWhat is Delivery?\nOrganization at GitLab\nRelationship to Continuous Delivery and Deployment\nGitLab's Delivery Vision\nJobs To Be done\nMarket\nProduct principles\nEmbrace the cloud-native ecosystem\nAim for experienced cloud users, but make it easy to get started for new users\nProvide an integrated experience\nBe enterprise ready\nStrategy\nKubernetes First\nFocus on Environments\nStrengths\nWeaknesses\nOpportunities\nThreats\nRoadmap\nCurrent Position\nFocus for FY25\nIntegrating Flux with the agent for Kubernetes\nTurn environments a central place for delivery data\nBuilding out a flexible delivery framework\nWhat we aren't focused on now\nKey Capabilities for Delivery\nConfigure\nRelease\nOverview\nThe delivery direction covers the deployment and release functionality of GitLab. Users of both cloud-native and legacy infrastructures should benefit from the delivery direction. This direction brings them high-level automations that just work out of the box following GitLab conventions and low-level integration points that enable users to build their own flavor of deployment and release functionality. Legacy infrastructures are served through GitLab CI/CD, while cloud-native infrastructures, especially Kubernetes, are supported with the agent for Kubernetes.\nWhat is Delivery?\nDelivery is when you promote a coded, integrated, and built software application to a production environment. Once you deliver an application, users derive value from it. Delivery is composed of two parts, deployment and release. Deployment covers the processes and actions needed to deploy a new version of the software to a target infrastructure. This includes both production and non-production infrastructures. Release includes the processes and actions needed to make a deployed application available to the users. As delivery starts with a tested artifact, like a container, it might take several deployments into various environments and a final release or set of releases for the container to serve users.\nDelivery is difficult, however, with the competition in the market today,\nincreased velocity and stability are a necessity\n. Delivery is where development and operations meet and the focus turns to operations. Delivery is a team sport. It requires empowered developers and it requires guardrails set by operators. In overcoming these hurdles,\nteams must\n:\nEnable Developers\n: Delivery is simple when done alone. It's hard when done across even a small number of teams. Doing it well requires automation, orchestration, coordination, and collaboration. Doing delivery at scale requires enabling developers to self-serve while maintaining system integrity, security and compliance.\nIncrease Frequency\n: Release frequency is a competitive advantage. Products must deploy frequently to capture value sooner and receive feedback quicker. Increasing deployment and release frequency decreases risks and sets the team up for continuous improvements. Teams need fast, repeatable, compliant and safe ways to deliver software to their users.\nAccommodate Target Variety\n: Deployment used to involve copying new files to a specific server. Today, deployment targets span environments (dev/staging/production), infrastructure types (VM and container). Adding to the complexity, some environments and their infrastructure are ephemeral. The release mechanisms differ by deployment targets. A release might take many forms, like switching a feature flag, reconfiguring a load-balancer, etc. Operations teams need to provide a consistent interface for deploying and releasing in different target environments.\nOrganization at GitLab\nEphemeral or declarative infrastructure blurs the line between infrastructure configuration, software development and software delivery. At GitLab, the Delivery direction belongs to\nthe Ops section\n, and it is primarily the responsibility of\nthe Environments group\n. At the same time, we acknowledge that Delivery does not exist in a vacuum. As already mentioned, Delivery is where the focus shifts from development to operations. As a result, the Delivery direction starts with a secure packaged artifact and should support and integrate well with Day-2 operations. These are covered by the\nSecure\n,\nPackage\nand\nMonitor\nstages of GitLab, respectively.\nRelationship to Continuous Delivery and Deployment\nThis direction is about delivery, in general. As a result, we speak about delivery overarching deployment and release functionalities. There are nevertheless two industry terms, \"continuous delivery\" and \"continuous deployment\" that might confuse the reader of this page. To remove this confusion, we provide here Martin Fowler's\ndefinition of these related terms\n:\nContinuous Delivery is a software development discipline where you build software in such a way that the software can be released to production at any time. â¦ Continuous Deployment means that every change goes through the pipeline and automatically gets put into production, resulting in many production deployments every day. â¦ Continuous Integration usually refers to integrating, building, and testing code within the development environment. Continuous Delivery builds on this, dealing with the final stages required for production deployment.\nThe Delivery direction includes both Continuous Delivery and Continuous Deployment, while Continuous Integration is covered by the\nVerify\nstage.\nGitLab's Delivery Vision\nGitLab's Delivery vision is to enable your organization to be an elite performer in DevOps by providing your tools and frameworks to automatically turn the hardest part of DevOps - software delivery - easy, flexible and secure.\nWe will accomplish this by\nEmpowering\nPriyanka (Platform Engineer)\nand\nIngrid (Infrastructure Operator)\nto define and automate DevOps practices that have security and compliance guard rails built directly into the process.\nProvide integrations, tools and frameworks for Priyanka and Ingrid that they can use without customizations or can fine-tune to provide a delivery platform for their users.\nThe delivery platform managed by Priyanka and Ingrid should enable developers to own their specific deployment operations without toil, increase their confidence in their delivery processes and support Day-2 operations.\nTaking advantage of the data available in the connected GitLab platform, from planning input, artifact storage to observability and incident data, to make release operations, such as scaling rollouts or rollbacks automatic.\nJobs To Be done\nWhen a developer is using the development platform, I want the developer to be more productive by not having to spend time figuring out how to deploy yet enable them to comply with security and compliance requirements.\nWhen operating the development platform, I do not want to slow down the development teams and limit what they need to do to improve and deploy their service so that there's no downside to using the platform.\nWhen operating the development platform, I empower engineers while retaining control with RBAC, Audit trails, secret management, progressive delivery, and auto-scaling deployments and rollbacks.\nWhen configuring my delivery pipelines, I can decide the people and teams with rights to deploy and release, so the pipeline can support the company culture and processes.\nWhen changing something in my organization's DevOps process, I do not want to create extra work for my development teams yet enable them to still benefit from the improvements in the process.\nWhen managing my environments, I want to see and understand what is currently running, so that I can make decisions on what I need to do.\nWhen delivering my application, it doesn't matter if I am delivering to legacy servers or to Kubernetes, it all just works.\nWhen releasing updates to my application, I feel confident my changes will not disrupt the existing environment and I know exactly what will be impacted.\nWhen releasing updates to my application, I feel confident about the delivery system and I know how I can recover from a failed delivery with minimal downtime.\nWhen looking for improvements in the delivery process, I can understand how my organization is performing, so that I can pinpoint actionable improvement areas.\nWhen delivering my application, I want to orchestrate the entire process, so that delivery pipeline users can use a well-functioning system.\nWe created\na glossary\nto discuss related terms in a consistent way.\nMarket\nThe total addressable market (TAMkt) for DevOps tools targeting the Delivery scope was\n$1.79B in 2020 and is expected to grow to $3.25B by 2024 (13.8% CAGR) (i)\n. This analysis is considered conservative as it focuses only on developers and doesn't include other users. External market sizing shows even more potential. For example, continuous delivery alone, which does not include categories such as infrastructure as code, is estimated to have a\nmarket size of $1.62B in 2018 growing to $6B by 2026 (17.76% CAGR)\n. This, like the\nOps market\nin general, is a deep value pool and represents a significant portion of GitLab's expanding addressable market.\nThe delivery tooling market is evolving and expanding. There are now many more options than just adding a deployment job to your CI/CD pipeline. Release Orchestration, advanced releases, GitOps, infrastructure provisioning, platform as a service, progressive delivery, and feature flags are all methodologies that help teams deliver software more easily, frequently, and confidently. Completeness of feature sets from vendors is becoming increasingly important as teams want the benefits from all worlds; traditional, table stakes deployment features alongside modern, differentiating features.\nTo increase deployment frequency and be competitive in the market, enterprises have turned to\ncentralized cloud teams or cloud center of excellence\nthat are responsible for helping\ndevelopment teams be more efficient and productive\n. These teams have centralized buying power for DevOps and delivery tools. They may also have organizational support to build a DIY DevOps platform. For cloud-native DIY platforms, we've found (through customer interviews) that open-source point deployment solutions (such as\nFlux\nor\nArgoCD\n) are the primary options because of their focus on cloud-native principles and early adoption of pull-based deployment. These tools often come with auxiliary tooling for release management, like\nFlagger\nand\nArgo Rollouts\nOtherwise, enterprises, even existing GitLab customers, sometimes buy commercial tools for deployment, such as Octopus, Harness, and CloudBees electric flow.\nProduct principles\nEmbrace the cloud-native ecosystem\nWe want to be good cloud-native citizens, build on top of and contribute back into open source tools. We believe in the power of the open source community and GitLab's everyone can contribute ethos.\nAim for experienced cloud users, but make it easy to get started for new users\nWe understand that Infrastructure as Code and cluster management at scale are complex, and best of breed technologies and much customization is required to fulfill advanced workflows. We want to support such advanced use cases. At the same time, we believe that many new users will become advanced users, and we can support them as well by providing production ready, turn-key solutions that incorporate the best practices followed by experts.\nProvide an integrated experience\nAt GitLab we build a single application for the whole Dev(Sec)Ops pipeline. Our solutions should integrate deeply with and should support other GitLab features. We are paying special attention to security and collaboration oriented features.\nBe enterprise ready\nWhile we want to provide supporting products for every company size, we expect enterprise users to have special needs that our integrated approach can serve well. Focusing on their use cases we can reduce their costs and enable faster go to market\nStrategy\nIn Delivery, our primary persona is\nPriyanka (Platform Engineer)\n. They are responsible for setting up the systems that development teams use to develop, test,\nship\n, and\noperate\ntheir applications.\nThey - likely - work at an enterprise where there is a mix of delivery targets from VMs to Kubernetes and bare metal to cloud infrastructure.\nThey also face the challenges of ever-increasing complexity; as more contributors, more services, more infrastructure, more databases, and a mix of technologies are added to their applications.\nThey are looking for ways to create a system to manage the complexity at scale, and especially to present the necessary parts of this complexity to their users, the application operators.\nIn line with Priyanka's users, our most important secondary persona is\nAllison (Application Operator)\n.\nAs our primary target customers are enterprise customers, we want to make sure that regulatory and compliance requirements related to application delivery are covered from the start. As a result, we pay special attention to the needs of\nCameron (Compliance Manager)\nand\nRachel (Release Manager)\n.\nand\nIngrid (Infrastructure Operator)\n.\nOur investment will focus on two strategic pillars.\nKubernetes First\nIn 2021, we have seen that\nKubernetes has officially gone main stream\n.\nThere are two compelling reasons why we want to be Kubernetes first\n(not Kubernetes only).\nFirst, we have seen that our customers are reaching out to GitLab after they have decided to modernize on Kubernetes as a platform. With the clear impetus to modernize, we want to meet our customers where they are at and provide capabilities that enable them to benefit from their modernization efforts.\nSecond, targeting Kubernetes enables us to be more efficient. As Kubernetes becomes more and more ubiquitous, building against Kubernetes is a shortcut around building specific integrations with cloud vendors. We now also have the foundational tool, the\nGitLab agent for Kubernetes\nto take advantage of the Kubernetes ecosystem. Given that the agent has permission to act within the cluster, we can enable integration with the rich ecosystem of K8s tools to enable powerful workflows all from within GitLab, while following Kubernetes'\noperator pattern\n. With it, we can do exciting things like\nconnect GitLab environments to the actual environment of the running application\n. Lastly but not least, Kubernetes is API driven. As such, we can move fast building on top of Kubernetes, instead of complicated undertakings such as figuring out how to connect with load balancers.\nFocus on Environments\nDeployments and releases always happen outside of GitLab, a target infrastructure that we call an environment. We want to make GitLab environments a central part of GitLab similar to merge requests.\nEnvironments should support automation, enable transparency and collaboration in each of the steps that lead up to a release across environments. We plan to focus on improving the connection between\nreleases\n,\nenvironments\n,\nKubernetes clusters\n.\nWe want to enrich the current environments views with all the related data from security scans, through Observability to DORA metrics.\nOur strategy insights are captured in the following SWOT analysis\nStrengths\nGitLab's large and healthy user base provides a great user pool that's relatively easy to reach.\nThere is plenty of potential for adoption within the existing user base.\nAs existing users constantly modernize their processes, we can grow together.\nThe fast adoption of the Infrastructure as Code product category showed that we can successfully address infrastructure teams' needs.\nParts of the delivery features have strong foundations that further integrations can be built upon. Specifically, the Kuberentes and OpenTofu/Terraform integrations fall in this area.\nThe single product group in the CD section managed to build up a high performing team with exceptional trust, openness, collaboration and willingness to act\nWeaknesses\nAs many categories were built when GitLab focused on bredth over depth, and there was no continued investment, a lot of our offering is extremely minimal, and often can not meet the needs of our ideal customers, large enterprises.\nThe current team size restricts our ability to improve existing features or build new ones as we barely cope with maintenance\nOpportunities\nThe application delivery market is currently maturing from custom tools to the product era. There are no clear winners or winning patterns yet.\nIf we manage to play an active part in these trends, instead of just following them, we might be able to capture an outstanding part of the overall market.\nThe CNCF ecosystem offers a large number of OSS that allow for integrations and partnerships. We should be careful though to offer a unified experience for GitLab users.\nAs GitLab decided to pick FluxCD, a matured CNCF project, as its recommended GitOps tool, by playing a more active role in the FluxCD community, we can have an impact on its direction, overall future, and position GitLab as an examplary player in the CNCF ecosystem\nBy offering competitive solutions, existing GitLab users are more likely to adopt GitLab features, than picking 3rd party tools.\nThreats\nGitLab application delivery features were built as simple extensions of its CI capabilities.\nThis often limits our ability to build CD oriented features as CI and CD have very different requirements.\nThe majority of GitLab team members have a poor understanding of application delivery, its complexities and requirements.\nAs a result it's often approached naively in external communications, positioning and investment decisions.\nCommunications often simplifies the whole domain to \"deploy\" while other aspects of the DevSecOps lifecycle are discussed in detail.\nInvestment decisions might not take into account the adoption patterns of the industry: It's much easier to switch a Planning, SCM or CI tool than a CD tool, because CD processes by definition affect a user's production infrastructure, thus changes are more risky.\nAs the team is already extremely thin, losing any team members might require GitLab to reconsider its strategy immediately and reactively\nThe CD section competes with its single product group competes with companies of 30-100 people who work on a smaller scope.\nVarious parts of the GitLab offering are built on 3rd party solutions. Some of these integrations are very outdated (e.g Unleash for feature flags) and might be broken by upstream changes.\nGitLab does not play a central role in any of the related open source projects.\nRoadmap\nCurrent Position\nGitLab has a market-leading CI/CD solution.\nDeployments and releases using GitLab's CI/CD pipelines work well for many use cases.\nGitLab users love the developer enablement provided by our robust pipeline definition language, but they find it painful to write and manage hundreds of lines of code to describe their custom delivery logic.\nSimilarly, orchestrating large deployments across projects is painful with GitLab.\nThis complexity is exacerbated by the complexity of infrastructure and the delivery domain.\nCustomers today look for alternative solutions, like FluxCD to hide some of the complexity from software engineering teams.\nIndependent software deliveries\n- for the delivery of individual projects that can be deployed in an automated fashion without coordination, developers deploy using CI/CD pipelines in the following ways:\nWriting\ncustomized pipeline definitions\nCustom pipeline can take advantage of functionalities made available in containers, including\nones published by GitLab\nIncluding\npipeline definitions provided by their platform teams\nUsing GitLab provided deployment\ntemplates\n(such as Pages, AWS, Fastlane, Serverless, 5 Minute App, etc)\nUtilizing GitLab's\nAutoDevOps\ndefined deployment process\nRelying on offered\nTerraform support\nKubernetes deployments\n- for deployments to Kubernetes, we have support for pull-based GitOps via the\nKubernetes Agent and FluxCD\n, while push-based GitOps is supported by\nCI/CD tunnel\n. Supporting both push- and pull-based deployments, GitLab can be used to migrate to full GitOps approaches of Kubernetes management and can support even dynamic use cases that pull-based only approaches struggle supporting.\nVisualising deployment status\n- once a deployment reaches its target infrastructure, application operators want to make sure that it's running smoothly and serves its users, and they want to be able to troubleshoot issues if needed. GitLab offers a minimal UI to show the status of deployments in Kubernetes.\nOrchestrated delivery\n- for complex releases, particularly those that require\norchestration\nacross multiple projects, release managers use\nReleases\nto gather artifacts. Sometimes release managers collaborate on the delivery process using GitLab's release.\nContinuous Delivery\n- many industries have strict regulatory requirements to follow that direct them to Continuous Delivery practices. GitLab supports Continuous Delivery via\nProtected environments\nand\nDeployment approval rules\n.\nNone of these methods are duplicative and each serves different use cases.\nFocus for FY25\nThe FY25 financial year runs from February 2024 to the end of January 2025. We will continue our focus on maintenance of existing functionality to ensure the stability of our offerings.\nWe plan a major redesign of the Environment pages.\nThe current design was built iteratively and information got sometimes added where it was easy not where it made sense.\nWe are rethinking the current layout to fix the suboptimal results of the aforementioned iteration and provide the foundations for more information to be highlighted on these pages in the future.\nWe continue building out visualisations for Kubernetes in the GitLab UI.\nWe want to reach to a state where application operators can debug their applications in non-production environments through the GitLab UI.\nProduction environments are in scope as a cross-section collaboration with\nthe Analytics Observability group\nwho own historical log storage and querying.\nTo further integrate Flux, we plan to simplify Flux management by using the agent for Kubernetes to manage all tokens needed by Flux.\nWe are looking into shipping AI support for troubleshooting Kubernetes issues with Duo Chat, and into shipping an opinionated application delivery framework, the successor of the Deploy component of Auto DevOps.\nIntegrating Flux with the agent for Kubernetes\nWe decided to\ndrop our in-house GitOps solution in favor of a Flux integration\n. Our plan is to provide value-add on top of a stand-alone Flux installation by:\nintegrating access management to avoid the management of deploy keys and tokens with Flux;\nproviding graphical insights into Flux deployments as part of the GitLab UI;\nintegrating GitOps with GitLab pipelines for smooth pre- and post deployment jobs.\nTogether with some other changes, we want to reach a point where we can finally remove the deprecated certificate-based integration.\nTurn environments a central place for delivery data\nEnvironments today are a light-weight and hidden mirror of your infrastructure status. We want to make them central for DevOps people to rely on when they start their day, want to understand whatâs running where or want to change the state of an environment.\nIntegrate with GitLab DORA metrics for deployment frequencies and lead time to change.\nIntegrating GitLab Observability into environments should provide the entry points to metrics, logs and tracing and improve the user experience to get an overview about the status of an environment.\nMake core environments data available widely across GitLab.\nBuilding out a flexible delivery framework\nWhile today users can use GitLab CI to code their delivery pipelines, they have to maintain the custom logic. We want to offer a fully declarative and flexible definition to describe delivery pipelines. We call this the GitLab Delivery Framework.\nThe framework is currently in the planning phase. More details are shared on\nthe Deployment management direction\n. In line with our Kubernetes first strategy, first, we want to add support for delivery pipelines targeting Kubernetes, later followed by other deployment and release targets.\nThe framework should:\nintegrate applications for core use cases (e.g. ingress, certificate manager);\nprovide a code-based deployment framework that allows describing the desired state of environments and how envrionments are promoted in a fully-automated way;\nprovide a GUI to make the code-based deployment framework accessible to everyone;\nadd support for advanced deployment and release strategies;\nexpand our solution beyond Kubernetes to other strategic deployment targets.\nWhat we aren't focused on now\nThere are important things we won't work on to focus on our one year plan.\nAuto DevOps Deployments\n- While we will enable the creation of Auto DevOps style templates and experiences for the developers in their organization by platform teams, we will not be making significant strides to make Auto DevOps deployments cover a broader set of delivery targets at this time.\nProgressive Delivery\n- By focusing on where platform teams are today, we'll forgo pushing further on our current progressive delivery capabilities like Feature Flags and A/B Testing.\nCost Optimization\n- We should first improve adoption of our Kubernetes Management capabilities before focusing more on cluster costs. Enterprises want views into costs beyond clusters. Building capabilities like environment management precedes cost optimization tooling.\nNon-Kubernetes Cloud-native\n- Distinguishing from\nKubernetes-native\n, which is our initial focus area. We will not be focused on other cloud-native solutions, such as Docker Swarm, Apache Mesos, and Amazon ECS, because they're not nearly as successful as Kubernetes. We might expand into these directions (especially AWS) as a follow-up.\nBuilding more Deployment Methods\n- Actively adding templates or improving existing templates is not our main focus. Nor is building customized images for deploying to cloud providers. The CI/CD pipeline is flexible and enables GitLab users to create what they need as is. It is worthwhile to examine how we can enable the wider GitLab community, including our customer success teams, to share and reuse similar templates and treat them as lego blocks that can be adopted and put to use quickly. These will be most beneficial for common deployment targets, such as Fargate and Lambda.\n**Non-cloud native: **We think that GitLab CI/CD pipelines are mature to support most non-cloud native deployment targets. We donât plan to invest in these because of their low ROI.\nAt the same time, we are looking into extending GitLab functionality in some of these areas through partner integrations.\nKey Capabilities for Delivery\nEnterprises are increasingly choosing to have a\ncloud-first strategy\n. Furthermore, with the increasing adoption of microservices architecture and infrastructure as code, traditional release tools are inadequate. This, coupled with the traditional delivery requirements of governance, compliance, and security, means that delivery tools have to meet a high bar and address a set of evolving technology and compliance requirements. The primary themes for these capabilities are that first organizations need\ncollaboration and transparency\n, then\ncontrol and compliance\nand before requiring\nmeasurement and advanced patterns\n. We list these key capabilities of deployment platforms in\npriority order of user need\n:\nCollaboration and Transparency\nEnvironment management:\nOrganizations typically operate multiple\nenvironments\n, each serving different needs. Delivery tools should help to make managing environments easy and intuitive.\nEverything as code:\nDelivery tooling, including pipelines, releases, infrastructure, environments, and monitoring tools, are constantly evolving. If they can be stored as code and version-controlled, it will enable organizations to more effectively collaborate and avoid costly mistakes.\nControl and Compliance\nGitOps:\nSimply checking code into a repository will not prevent drift to occur between code and what is deployed.\nGitOps\nsolves this problem by automatically managing changes using the single source of truth reflected in the source repository providing more control by preventing drift.\nRelease Orchestration & Quality gates:\nOrganizations need to control what can be deployed and in which sequence. Enabling reviews and approvals built right into the deployment workflow and supporting policy tools is a critical requirement. The ability to perform automatic rollback, environment freeze, and scaling deployment also enables organizations to be more in control.\nMeasurement and Advanced Patterns\nFeedback:\nDelivery is a critical part of the DevOps feedback loop. A successful release depends on immediate feedback from Monitoring and Observability tools to ensure a healthy rollout. Furthermore, knowing that a delivery was successful is not just about knowing whether the application deployed is healthy, it also requires understanding the impact to downstream neighbors and the environment as a whole.\nReporting:\nUnderstanding how the DevOps team and the entire organization is performing, such as using the DORA metrics, is important to enable iteration towards stronger performance.\nProgressive delivery:\nDelivery can be risky. To mitigate risks, progressive delivery techniques, such as using feature flags, canary and rolling deployments can help mitigate the risk by limiting the impact until the delivery teams are confident that their changes are good to go.\nEdit this page\nView source",
  "html_file": "5e3a999debb391ce.html"
}